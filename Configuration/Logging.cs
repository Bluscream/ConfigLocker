using ConfigLocker;
using System.Collections.Generic;
using System.Text.Json.Serialization;

#nullable enable
#pragma warning disable CS8618
#pragma warning disable CS8601
#pragma warning disable CS8603

public partial class Configuration {
    // <auto-generated />
    //
    // To parse this JSON data, add NuGet 'System.Text.Json' then do:
    //
    //    using ConfigLocker;
    //
    //    var sourceList = SourceList.FromJson(jsonString);
    #region NLog
    [JsonPropertyName("Logging")]
    public virtual Logging Logging { get; set; }
    [JsonPropertyName("NLog")]
    public virtual SourceListNLog NLog { get; set; }
    #endregion NLog
}
#region NLog
public partial class Logging {
    [JsonPropertyName("NLog")]
    public virtual LoggingNLog NLog { get; set; }
}
public partial class LoggingNLog {
    [JsonPropertyName("IncludeScopes")]
    public virtual bool IncludeScopes { get; set; }

    [JsonPropertyName("ParseMessageTemplates")]
    public virtual bool ParseMessageTemplates { get; set; }

    [JsonPropertyName("CaptureMessageProperties")]
    public virtual bool CaptureMessageProperties { get; set; }
}
public partial class SourceListNLog {
    [JsonPropertyName("autoreload")]
    public virtual bool Autoreload { get; set; }

    [JsonPropertyName("internalLogLevel")]
    public virtual string InternalLogLevel { get; set; }

    [JsonPropertyName("internalLogFile")]
    public virtual string InternalLogFile { get; set; }

    [JsonPropertyName("throwConfigExceptions")]
    public virtual bool ThrowConfigExceptions { get; set; }

    [JsonPropertyName("targets")]
    public virtual Targets Targets { get; set; }

    [JsonPropertyName("rules")]
    public virtual List<Rule> Rules { get; set; }
}
public partial class Rule {
    [JsonPropertyName("logger")]
    public virtual string Logger { get; set; }

    [JsonPropertyName("minLevel")]
    public virtual string MinLevel { get; set; }

    [JsonPropertyName("writeTo")]
    public virtual string WriteTo { get; set; }
}
public partial class Targets {
    [JsonPropertyName("console")]
    public virtual ConsoleClass Console { get; set; }

    [JsonPropertyName("file")]
    public virtual TargetFile File { get; set; }
}
public partial class ConsoleClass {
    [JsonPropertyName("type")]
    public virtual string Type { get; set; }

    [JsonPropertyName("layout")]
    public virtual string Layout { get; set; }
}
public partial class TargetFile {
    [JsonPropertyName("type")]
    public virtual string Type { get; set; }

    [JsonPropertyName("target")]
    public virtual Target Target { get; set; }
}
public partial class Target {
    [JsonPropertyName("wrappedFile")]
    public virtual WrappedFile WrappedFile { get; set; }
}
public partial class WrappedFile {
    [JsonPropertyName("type")]
    public virtual string Type { get; set; }

    [JsonPropertyName("fileName")]
    public virtual string FileName { get; set; }

    [JsonPropertyName("layout")]
    public virtual WrappedFileLayout Layout { get; set; }
}
public partial class WrappedFileLayout {
    [JsonPropertyName("type")]
    public virtual string Type { get; set; }

    [JsonPropertyName("Attributes")]
    public virtual List<Attribute> Attributes { get; set; }
}
public partial class Attribute {
    [JsonPropertyName("name")]
    public virtual string Name { get; set; }

    [JsonPropertyName("layout")]
    public virtual LayoutUnion Layout { get; set; }

    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyName("encode")]
    public virtual bool? Encode { get; set; }
}
public partial class LayoutLayout {
    [JsonPropertyName("type")]
    public virtual string Type { get; set; }

    [JsonPropertyName("includeallproperties")]
    [JsonConverter(typeof(ParseStringConverter))]
    public virtual bool Includeallproperties { get; set; }
}
public partial struct LayoutUnion {
    public LayoutLayout LayoutLayout;
    public string String;

    public static implicit operator LayoutUnion(LayoutLayout LayoutLayout) => new LayoutUnion { LayoutLayout = LayoutLayout };
    public static implicit operator LayoutUnion(string String) => new LayoutUnion { String = String };
}
#endregion NLog

#pragma warning restore CS8618
#pragma warning restore CS8601
#pragma warning restore CS8603